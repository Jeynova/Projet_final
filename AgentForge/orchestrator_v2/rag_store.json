{
  "docs": [
    {
      "doc_id": "app/main.py",
      "text": "FILE: app/main.py\nSUMMARY: The `app/main.py` file sets up a FastAPI application with CORS middleware, routes for task and project management, and basic health and root endpoints. It includes database startup and shutdown event handlers, but the actual database operations are not defined in this file.\nCONTENT:\nfrom fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom sqlalchemy.orm import Session\nfrom app.core.config import settings\nfrom app.db.session import get_db\nfrom app.routers import task_router, project_router\n\napp = FastAPI(\n    title=settings.PROJECT_NAME,\n    description=settings.PROJECT_DESCRIPTION,\n)\n\n# CORS Configuration\norigins = [\n    \"*\",\n]\n\ncors_middleware = CORSMiddleware(\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\napp.add_middleware(CORSMiddleware, **cors_middleware.dict())\n\n# Include routers\napp.include_router(task_router.router)\napp.include_router(project_router.router)\n\n# Database initialization and shutdown events (if needed)\n@app.on_event(\"startup\")\ndef startup_db():\n    db = next(get_db())\n    # Perform any necessary database setup or migrations here\n\n@app.on_event(\"shutdown\")\ndef shutdown_db():\n    pass  # Placeholder for shutdown logic if needed\n\n# Basic health endpoint\n@app.get(\"/health\", status_code=status.HTTP_200_OK)\ndef check_health():\n    return {\"status\": \"ok\"}\n\n# Root endpoint\n@app.get(\n    \"/\",\n    response_model=str,\n    summary=\"Root endpoint for the API\",\n    description=\"Returns a simple message indicating that the server is running.\",\n)\ndef root():\n    return \"Welcome to the Project Management System!\"\n",
      "metadata": {
        "type": "code",
        "len": 1379
      },
      "added": 1756648913.3929124
    },
    {
      "doc_id": "app/models/__init__.py",
      "text": "FILE: app/models/__init__.py\nSUMMARY: # models package\n# Generated for: app/models/__init__.py\nprint('LLM-generated placeholder for app/models/__init__.py')\n\nCONTENT:\n# models package\n# Generated for: app/models/__init__.py\nprint('LLM-generated placeholder for app/models/__init__.py')\n",
      "metadata": {
        "type": "code",
        "len": 119
      },
      "added": 1756648192.5714993
    },
    {
      "doc_id": "app/routes/__init__.py",
      "text": "FILE: app/routes/__init__.py\nSUMMARY: # routes package\n# Generated for: app/routes/__init__.py\nprint('LLM-generated placeholder for app/routes/__init__.py')\n\nCONTENT:\n# routes package\n# Generated for: app/routes/__init__.py\nprint('LLM-generated placeholder for app/routes/__init__.py')\n",
      "metadata": {
        "type": "code",
        "len": 119
      },
      "added": 1756648192.5770135
    },
    {
      "doc_id": "app/schemas.py",
      "text": "FILE: app/schemas.py\nSUMMARY: from pydantic import BaseModel, Field\nfrom typing import Optional, List\nfrom datetime import datetime\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=200)\n    descri\nCONTENT:\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List\nfrom datetime import datetime\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=200)\n    description: Optional[str] = Field(None, max_length=500)\n    price: float = Field(..., gt=0)\n    stock: int = Field(..., ge=0)\n    category: Optional[str] = Field(None, max_length=100)\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass ProductResponse(ProductBase):\n    id: int\n    created_at: datetime\n    \n    class Config:\n        from_attributes = True\n\nclass UserBase(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n    email: str = Field(..., regex=r'^[^@]+@[^@]+\\.[^@]+$')\n\nclass UserCreate(UserBase):\n    pass\n\nclass UserResponse(UserBase):\n    id: int\n    created_at: datetime\n    \n    class Config:\n        from_attributes = True\n\nclass CartItem(BaseModel):\n    product_id: int\n    quantity: int = Field(..., gt=0)\n\nclass CartResponse(BaseModel):\n    items: List[CartItem]\n    total: float\n",
      "metadata": {
        "type": "code",
        "len": 1018
      },
      "added": 1756648192.5805063
    },
    {
      "doc_id": "tests/__init__.py",
      "text": "FILE: tests/__init__.py\nSUMMARY: The file `tests/__init__.py` is a placeholder generated by an LLM (Large Language Model) for the `tests` package in a Python project. It currently contains a simple print statement that outputs 'LLM-generated placeholder for tests/__init__.py'. This file is typically used to indicate that the directory is intended as a Python package, but does not contain any actual test code.\nCONTENT:\n# tests package (validator)\n# Generated for: tests/__init__.py\nprint('LLM-generated placeholder for tests/__init__.py')\n",
      "metadata": {
        "type": "code",
        "len": 120
      },
      "added": 1756648192.5850115
    },
    {
      "doc_id": "app/routes/health.py",
      "text": "FILE: app/routes/health.py\nSUMMARY: This file defines a FastAPI route for checking the health of the application. The route `/health` returns a JSON response with a single key `ok` set to `True`, indicating that the application is healthy.\nCONTENT:\nfrom fastapi import APIRouter\nrouter = APIRouter()\n@router.get('/health')\nasync def health():\n    return {'ok': True}\n",
      "metadata": {
        "type": "code",
        "len": 118
      },
      "added": 1756648192.5904312
    },
    {
      "doc_id": "success_1756644237_75",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 75/100\nPrompt: Create a simple ecommerce API with FastAPI\nTech Stack: python, fastapi, sqlite\nFiles Generated: 6\nArchitecture Pattern: Clean Architecture\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: ['python', 'fastapi', 'sqlite']\n- Generated 6 files with score 75\n- Architecture: Clean Architecture\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\necommerce\n\nTECH STACK EFFECTIVENESS:\nGood match: ['python', 'fastapi', 'sqlite'] worked well for this type of project\n\nFILES CREATED:\napp/main.py\napp/models/__init__.py\napp/routes/__init__.py\napp/schemas.py\ntests/__init__.py\napp/routes/health.py",
      "metadata": {
        "type": "knowledge",
        "score": 75,
        "tech_stack": [
          "python",
          "fastapi",
          "sqlite"
        ],
        "file_count": 6,
        "prompt_category": "ecommerce",
        "added": 1756644237.460129
      },
      "added": 1756644237.460129
    },
    {
      "doc_id": "test_knowledge",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 85/100\nPrompt: Create a simple ecommerce API with FastAPI  \nTech Stack: python, fastapi, sqlite\nFiles Generated: 8\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: python, fastapi, sqlite\n- Generated 8 files with score 85\n- Ecommerce projects work great with FastAPI + SQLite\n",
      "metadata": {
        "type": "knowledge",
        "score": 85
      },
      "added": 1756644252.5903583
    },
    {
      "doc_id": "success_1756644273_78",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 78/100\nPrompt: Create an ecommerce platform with FastAPI\nTech Stack: python, fastapi, sqlite\nFiles Generated: 6\nArchitecture Pattern: Clean Architecture\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: ['python', 'fastapi', 'sqlite']\n- Generated 6 files with score 78\n- Architecture: Clean Architecture\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\necommerce\n\nTECH STACK EFFECTIVENESS:\nGood match: ['python', 'fastapi', 'sqlite'] worked well for this type of project\n\nFILES CREATED:\napp/main.py\napp/models/__init__.py\napp/routes/__init__.py\napp/schemas.py\ntests/__init__.py\napp/routes/health.py",
      "metadata": {
        "type": "knowledge",
        "score": 78,
        "tech_stack": [
          "python",
          "fastapi",
          "sqlite"
        ],
        "file_count": 6,
        "prompt_category": "ecommerce",
        "added": 1756644273.3914268
      },
      "added": 1756644273.3914268
    },
    {
      "doc_id": "success_1756644273_75",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 75/100\nPrompt: Build an online store API with FastAPI\nTech Stack: python, fastapi, sqlite\nFiles Generated: 6\nArchitecture Pattern: Clean Architecture\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: ['python', 'fastapi', 'sqlite']\n- Generated 6 files with score 75\n- Architecture: Clean Architecture\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\necommerce\n\nTECH STACK EFFECTIVENESS:\nGood match: ['python', 'fastapi', 'sqlite'] worked well for this type of project\n\nFILES CREATED:\napp/main.py\napp/models/__init__.py\napp/routes/__init__.py\napp/schemas.py\ntests/__init__.py\napp/routes/health.py",
      "metadata": {
        "type": "knowledge",
        "score": 75,
        "tech_stack": [
          "python",
          "fastapi",
          "sqlite"
        ],
        "file_count": 6,
        "prompt_category": "ecommerce",
        "added": 1756644273.467744
      },
      "added": 1756644273.467744
    },
    {
      "doc_id": "app/models/user.py",
      "text": "FILE: app/models/user.py\nSUMMARY: This Python file defines a `User` model using Pydantic's `BaseModel`. The `User` class includes attributes for `id`, which is optional and of type `int`, and `name`, which is required and of type `str`. This model can be used to validate and represent user data in applications that utilize Pydantic for data modeling.\nCONTENT:\nfrom pydantic import BaseModel\nclass User(BaseModel):\n    id: int | None = None\n    name: str\n",
      "metadata": {
        "type": "code",
        "len": 94
      },
      "added": 1756647195.8720584
    },
    {
      "doc_id": "app/routes/users.py",
      "text": "FILE: app/routes/users.py\nSUMMARY: {'file_name': 'app/routes/users.py', 'description': 'This file defines a FastAPI router for handling user-related operations.', 'endpoints': [{'method': 'POST', 'path': '/users/', 'tags': ['users'], 'response_model': 'User', 'description': 'Creates a new user and returns the created user object with an assigned ID.'}, {'method': 'GET', 'path': '/users/', 'tags': ['users'], 'response_model': 'list[User]', 'description': 'Returns a list of all users.'}], 'models': [{'name': 'User', 'description': 'A Pydantic model representing a user with an optional ID and a name.', 'fields': {'id': {'type': 'int', 'nullable': True, 'description': 'The unique identifier for the user.'}, 'name': {'type': 'str', 'description': 'The name of the user.'}}}], 'internal_state': [{'variable_name': '_db', 'type': 'list[User]', 'description': 'A list to store all user objects in memory.'}]}\nCONTENT:\nfrom fastapi import APIRouter\nfrom pydantic import BaseModel\nrouter = APIRouter(prefix='/users', tags=['users'])\nclass User(BaseModel):\n    id: int | None = None\n    name: str\n_db: list[User] = []\n@router.post('/', response_model=User)\nasync def create_user(data: User):\n    data.id = len(_db)+1\n    _db.append(data)\n    return data\n@router.get('/', response_model=list[User])\nasync def list_users():\n    return _db\n",
      "metadata": {
        "type": "code",
        "len": 416
      },
      "added": 1756647200.8081334
    },
    {
      "doc_id": "success_1756644870_80",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 80/100\nPrompt: Create a FastAPI ecommerce API with products, users, and cart functionality\nTech Stack: python, fastapi, sqlite\nFiles Generated: 8\nArchitecture Pattern: Clean Architecture\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: ['python', 'fastapi', 'sqlite']\n- Generated 8 files with score 80\n- Architecture: Clean Architecture\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\necommerce\n\nTECH STACK EFFECTIVENESS:\nGood match: ['python', 'fastapi', 'sqlite'] worked well for this type of project\n\nFILES CREATED:\napp/main.py\napp/models/__init__.py\napp/routes/__init__.py\napp/schemas.py\ntests/__init__.py\napp/routes/health.py\napp/models/user.py\napp/routes/users.py",
      "metadata": {
        "type": "knowledge",
        "score": 80,
        "tech_stack": [
          "python",
          "fastapi",
          "sqlite"
        ],
        "file_count": 8,
        "prompt_category": "ecommerce",
        "added": 1756644870.1345646
      },
      "added": 1756644870.1345646
    },
    {
      "doc_id": "main.py",
      "text": "FILE: main.py\nSUMMARY: main.py is the main entry file for a FastAPI application designed to manage tasks. It sets up the app with CORS middleware, includes routes for task management, initializes the database using SQLAlchemy, and handles startup and shutdown events.\nCONTENT:\nfrom fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom app.config import Settings\nfrom app.auth.jwt_auth import get_current_user\nfrom app.routes.task_routes import task_router\nfrom app.services.task_service import init_db\n\n# Initialize FastAPI app with title and description\ntitle = \"Task Management System\"\ndescription = \"A simple task management system for teams using FastAPI, SQLAlchemy, and JWT authentication.\"\napp = FastAPI(title=title, description=description)\n\n# Add CORS middleware configuration\norigins = [\"http://localhost\", \"http://localhost:8080\"]\ncors_middleware = CORSMiddleware(\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\napp.add_middleware(CORSMiddleware, **cors_middleware.dict())\n\n# Include all route modules with app.include_router\napp.include_router(task_router)\n\n# Add database initialization logic\nsettings = Settings()\necho_mode = True if settings.environment == \"development\" else False\ndb_engine = create_engine(settings.database_url, echo=echo_mode)\ndb_session_local = sessionmaker(autocommit=False, autoflush=False, bind=db_engine)\n\n@app.on_event(\"startup\")\ndef startup_event():\n    init_db()\n\n# Include shutdown events if needed\ndef close_db_connection(exc):\n    db_session_local.close()\napp.add_event_handler(\"shutdown\", close_db_connection)\n\n# Add basic health and r",
      "metadata": {
        "type": "code",
        "len": 1879
      },
      "added": 1756647280.5465412
    },
    {
      "doc_id": "config/settings.py",
      "text": "FILE: config/settings.py\nSUMMARY: This file contains the configuration settings for a Python application using Pydantic. It defines various environment variables and their default values, such as SECRET_KEY, ALGORITHM, ACCESS_TOKEN_EXPIRE_MINUTES, DATABASE_URL, SQLALCHEMY_DATABASE_URI, FIRST_SUPERUSER, and FIRST_SUPERUSER_PASSWORD. The class Settings inherits from BaseSettings and uses environment variables if available, otherwise falling back to default values. The Config class specifies the location of the .env file for loading environment variables and their encoding.\nCONTENT:\nimport os\nfrom pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    SECRET_KEY: str = os.getenv('SECRET_KEY', 'default_secret_key')\n    ALGORITHM: str = 'HS256'\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    DATABASE_URL: str = os.getenv('DATABASE_URL', 'sqlite:///./test.db')\n    SQLALCHEMY_DATABASE_URI: str = DATABASE_URL.replace('postgres://', 'postgresql+psycopg2://')\n    FIRST_SUPERUSER: str = os.getenv('FIRST_SUPERUSER', 'admin@example.com')\n    FIRST_SUPERUSER_PASSWORD: str = os.getenv('FIRST_SUPERUSER_PASSWORD', 'admin1234567890')\n\n    class Config:\n        env_file = '.env'\n        env_file_encoding = 'utf-8'\n\n\nsettings = Settings()\n",
      "metadata": {
        "type": "code",
        "len": 660
      },
      "added": 1756645031.1884637
    },
    {
      "doc_id": "app/models.py",
      "text": "FILE: app/models.py\nSUMMARY: {'file_name': 'app/models.py', 'description': 'This file defines the data models for a blog application using SQLAlchemy and Pydantic.', 'models': [{'name': 'User', 'fields': [{'name': 'id', 'type': 'Integer'}, {'name': 'username', 'type': 'String'}, {'name': 'email', 'type': 'String'}, {'name': 'password_hash', 'type': 'String'}], 'pydantic_config': {'orm_mode': True}}, {'name': 'BlogPost', 'fields': [{'name': 'id', 'type': 'Integer'}, {'name': 'title', 'type': 'String'}, {'name': 'content', 'type': 'String'}, {'name': 'author_id', 'type': 'Integer'}, {'name': 'created_at', 'type': 'DateTime'}], 'pydantic_config': {'orm_mode': True}, 'relationships': [{'model': 'User', 'type': 'one_to_many', 'backref_name': 'blog_posts'}]}, {'name': 'Comment', 'fields': [{'name': 'id', 'type': 'Integer'}, {'name': 'content', 'type': 'String'}, {'name': 'blog_post_id', 'type': 'Integer'}, {'name': 'author_id', 'type': 'Integer'}, {'name': 'created_at', 'type': 'DateTime'}], 'pydantic_config': {'orm_mode': True}, 'relationships': [{'model': 'User', 'type': 'one_to_many', 'backref_name': 'comments'}, {'model': 'BlogPost', 'type': 'many_to_one', 'backref_name': 'comments'}]}]}\nCONTENT:\nfrom sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Index\nfrom sqlalchemy.orm import relationship, backref\nfrom datetime import datetime\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int\n    username: str\n    email: str\n    password_hash: str\n\n    class Config:\n        orm_mode = True\n\n\nclass BlogPost(BaseModel):\n    id: int\n    title: str\n    content: str\n    author_id: int\n    created_at: datetime\n\n    class Config:\n        orm_mode = True\n\n    user = relationship('User', backref=backref('blog_posts', lazy=True))\n\n\nclass Comment(BaseModel):\n    id: int\n    content: str\n    blog_post_id: int\n    author_id: int\n    created_at: datetime\n\n    class Config:\n        orm_mode = True\n\n    user = relationship('User', backref=backref('comments', lazy=True))\n    blog_post = relationship('BlogPost', backref=backref('comments', lazy=True))\n",
      "metadata": {
        "type": "code",
        "len": 877
      },
      "added": 1756647172.3985195
    },
    {
      "doc_id": "app/routes.py",
      "text": "FILE: app/routes.py\nSUMMARY: The `app/routes.py` file defines routes and endpoints for a FastAPI application. It includes CRUD operations for products and user authentication. The product endpoints support creating, retrieving (both all and by ID), updating, and deleting products. User authentication is handled with endpoints for login and creating new users.\nCONTENT:\nfrom fastapi import APIRouter, Depends, HTTPException, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom config.settings import get_db\nfrom app.models import Product, CartItem, User\nfrom app.schemas import ProductCreate, ProductUpdate, CartItemCreate, CartItemUpdate, UserCreate, UserLogin, UserResponse\nfrom app.crud import product_crud, cart_item_crud, user_crud\nfrom auth import authenticate_user, create_access_token\n\nrouter = APIRouter()\n\n@router.post(\"/products\", response_model=Product)\ndef create_product(product: ProductCreate, db: Session = Depends(get_db)):\n    return product_crud.create(db, obj_in=product)\n\n@router.get(\"/products\", response_model=List[Product])\ndef read_products(skip: int = Query(0), limit: int = Query(100), db: Session = Depends(get_db)):\n    products = product_crud.read_all(db, skip=skip, limit=limit)\n    return products\n\n@router.get(\"/products/{product_id}\", response_model=Product)\ndef read_product(product_id: int, db: Session = Depends(get_db)):\n    product = product_crud.read_by_id(db, id=product_id)\n    if not product:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    return product\n\n@router.put(\"/products/{product_id}\", response_model=Product)\ndef update_product(product_id: int, product: ProductUpdate, db: Session = Depends(get_db)):\n    return product_crud.update(db, id=product_id, obj_in=product)\n\n@router.delete(\"/products/{product_id}\", status_code=204)\ndef delete_product(product_id: int, db: Sess",
      "metadata": {
        "type": "code",
        "len": 3299
      },
      "added": 1756645039.8438528
    },
    {
      "doc_id": "tests/conftest.py",
      "text": "FILE: tests/conftest.py\nSUMMARY: This file sets up a test environment for an API using FastAPI and SQLAlchemy. It configures a SQLite database, creates the necessary tables based on the models defined in 'app.db.session', and includes routers from 'app.routers.project_router' and 'app.routers.task_router'. A fixture named 'client' is provided to be used in tests, which yields a TestClient instance for interacting with the API.\nCONTENT:\nimport pytest\nfrom sqlalchemy import create_engine\ndb_url = \"sqlite:///./test.db\"\necho = False\nengine = create_engine(db_url, connect_args={}, echo=echo)\nfrom app.db.session import Base, get_db\nBase.metadata.create_all(bind=engine)\nfrom app.routers.project_router import project_router\nfrom app.routers.task_router import task_router\napp = FastAPI()\napp.include_router(project_router)\napp.include_router(task_router)\n\n@pytest.fixture(autouse=True)\ndef client():\n    with TestClient(app) as client:\n        yield client\n",
      "metadata": {
        "type": "code",
        "len": 519
      },
      "added": 1756648915.5882053
    },
    {
      "doc_id": "tests/test_main.py",
      "text": "FILE: tests/test_main.py\nSUMMARY: This file sets up a FastAPI application for a blog platform with user authentication and comments. It includes CORS configuration, database initialization, startup and shutdown events, and routes for users, blogs, and comments.\nCONTENT:\nfrom fastapi import FastAPI, HTTPException, Depends, status\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom app.config import settings\nfrom app.models import Base\nfrom app.db import engine, get_db\nfrom app.auth import verify_token\nfrom app.routers import user_router, blog_router, comment_router\n\napp = FastAPI(\n    title=\"Blog Platform\",\n    description=\"A blog platform with user authentication and comments\",\n)\n\n# CORS configuration\norigins = [\n    \"http://localhost\",\n    \"http://localhost:8080\",\n]\ncors_middleware = CORSMiddleware(\n    app=app,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Include routers\napp.include_router(user_router, prefix=\"/api/v1\")\napp.include_router(blog_router, prefix=\"/api/v1\")\napp.include_router(comment_router, prefix=\"/api/v1\")\n\n# Database initialization\nBase.metadata.create_all(bind=engine)\n\n# Startup and shutdown events\n@app.on_event(\"startup\")\ndef startup():\n    try:\n        db = sessionmaker(autocommit=False, autoflush=False, bind=engine)()\n        db.execute(\"SELECT 1\")\n        print(\"Database connected successfully\")\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))\n\n@app.on_event(\"shutdown\")\ndef shutdown():\n    try:\n        db = sessionmaker(autocommit=False, autoflush=False, bind=engine)()\n        print(\"Database connection c",
      "metadata": {
        "type": "code",
        "len": 1834
      },
      "added": 1756647186.6961055
    },
    {
      "doc_id": "tests/test_routes.py",
      "text": "FILE: tests/test_routes.py\nSUMMARY: Ce fichier Python contient des tests pour une application FastAPI qui g\u00e8re les produits. Il inclut des routes pour cr\u00e9er, r\u00e9cup\u00e9rer (liste et par ID), et mettre \u00e0 jour un produit. Les routes utilisent SQLAlchemy pour interagir avec la base de donn\u00e9es et retournent des mod\u00e8les de sch\u00e9ma personnalis\u00e9s. La pagination est \u00e9galement impl\u00e9ment\u00e9e pour l'endpoint de liste des produits.\nCONTENT:\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom app.config.database import get_db\nfrom app.models.product import Product\nfrom app.schemas.product import ProductCreate, ProductUpdate, ProductResponse\nfrom sqlalchemy import desc\nfrom sqlalchemy.orm import joinedload\nfrom fastapi.pagination import Page, paginate\n\napp = FastAPI()\n\n@app.post('/products/', response_model=ProductResponse)\ndef create_product(product: ProductCreate, db: Session = Depends(get_db)):\n    new_product = Product(**product.dict())\n    db.add(new_product)\n    db.commit()\n    db.refresh(new_product)\n    return new_product\n\n@app.get('/products/', response_model=Page[ProductResponse])\ndef get_products(db: Session = Depends(get_db), page_size: int = 10, page_number: int = 1):\n    products = db.query(Product).options(joinedload('categories')).order_by(desc(Product.id)).paginate(page=page_number, per_page=page_size)\n    return paginate(products)\n\n@app.get('/products/{product_id}', response_model=ProductResponse)\ndef get_product(product_id: int, db: Session = Depends(get_db)):\n    product = db.query(Product).options(joinedload('categories')).filter(Product.id == product_id).first()\n    if not product:\n        raise HTTPException(status_code=404, detail='Product not found')\n    return product\n\n@app.put('/products/{product_id}', response_model=ProductResponse)\ndef update_product(product_id: int, product_update: ProductUpdate, db: Session = Depends(get",
      "metadata": {
        "type": "code",
        "len": 2155
      },
      "added": 1756645068.7765026
    },
    {
      "doc_id": "success_1756645071_80",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 80/100\nPrompt: Create a comprehensive FastAPI ecommerce platform with user authentication and product catalog\nTech Stack: \nFiles Generated: 9\nArchitecture Pattern: Microservices Architecture\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: []\n- Generated 9 files with score 80\n- Architecture: Microservices Architecture\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\necommerce\n\nTECH STACK EFFECTIVENESS:\nGood match: [] worked well for this type of project\n\nFILES CREATED:\nmain.py\nconfig/settings.py\napp/models.py\napp/routes.py\napp/schemas.py\ntests/conftest.py\ntests/test_main.py\ntests/test_routes.py\napp/main.py",
      "metadata": {
        "type": "knowledge",
        "score": 80,
        "tech_stack": [],
        "file_count": 9,
        "prompt_category": "ecommerce",
        "added": 1756645071.4035573
      },
      "added": 1756645071.4035573
    },
    {
      "doc_id": "app/crud.py",
      "text": "FILE: app/crud.py\nSUMMARY: Ce fichier contient des fonctions pour g\u00e9rer les op\u00e9rations CRUD (Create, Read, Update, Delete) sur les produits dans une application. Les fonctionnalit\u00e9s incluent la cr\u00e9ation d'un produit, la r\u00e9cup\u00e9ration d'un produit par son ID, la mise \u00e0 jour d'un produit et la suppression d'un produit. Chaque fonction utilise SQLAlchemy pour interagir avec la base de donn\u00e9es et retourne des erreurs HTTP appropri\u00e9es en cas de probl\u00e8me.\nCONTENT:\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom app.schemas import ProductCreate, ProductUpdate, CartItemCreate, UserCreate\nfrom app.models import Product, CartItem, User\nfrom app.db import get_db\n\nasync def create_product(product: ProductCreate, db: Session = Depends(get_db)) -> Product:\n    try:\n        product_obj = Product(**product.dict())\n        db.add(product_obj)\n        db.commit()\n        db.refresh(product_obj)\n        return product_obj\n    except SQLAlchemyError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\nasync def get_product(id: int, db: Session = Depends(get_db)) -> Product:\n    try:\n        product = db.query(Product).filter(Product.id == id).first()\n        if not product:\n            raise HTTPException(status_code=404, detail='Product not found')\n        return product\n    except SQLAlchemyError as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\nasync def update_product(id: int, product_update: ProductUpdate, db: Session = Depends(get_db)) -> Product:\n    try:\n        product = await get_product(id, db)\n        for key, value in product_update.dict(exclude_unset=True).items():\n            setattr(product, key, value)\n        db.commit()\n        db.refresh(product)\n        return product\n    except SQLAlchemyError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\nasync def delete_product(id: int, db: Session = Depends(get_db)) -> None:\n    try:\n        product = awai",
      "metadata": {
        "type": "code",
        "len": 3814
      },
      "added": 1756645428.104177
    },
    {
      "doc_id": "app/config.py",
      "text": "FILE: app/config.py\nSUMMARY: {'file_name': 'app/config.py', 'description': \"This file contains configuration settings for an application using Pydantic's BaseSettings class. It includes environment variables such as SECRET_KEY, ALGORITHM, and ACCESS_TOKEN_EXPIRE_MINUTES with validation to ensure that the access token expiration time is greater than 0.\", 'class_name': 'Settings', 'base_class': 'BaseSettings', 'environment_variables': {'SECRET_KEY': {'type': 'str', 'description': 'The secret key used for cryptographic signing.'}, 'ALGORITHM': {'type': 'str', 'description': 'The algorithm to be used for cryptographic operations.'}, 'ACCESS_TOKEN_EXPIRE_MINUTES': {'type': 'int', 'description': 'The time in minutes after which the access token expires.', 'validation': 'must be greater than 0'}}, 'config_class': {'env_file': '.env', 'env_file_encoding': 'utf-8'}}\nCONTENT:\nfrom pydantic import BaseSettings, validator\nfrom datetime import timedelta\nimport os\n\n\nclass Settings(BaseSettings):\n    SECRET_KEY: str = os.getenv('SECRET_KEY', 'your_secret_key_here')\n    ALGORITHM: str = os.getenv('ALGORITHM', 'HS256')\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = os.getenv('ACCESS_TOKEN_EXPIRE_MINUTES', 30)\n\n    @validator('ACCESS_TOKEN_EXPIRE_MINUTES', pre=True)\n    def check_access_token_expire_minutes(cls, value):\n        if value <= 0:\n            raise ValueError('ACCESS_TOKEN_EXPIRE_MINUTES must be greater than 0')\n        return value\n\n    class Config:\n        env_file = '.env'\n        env_file_encoding = 'utf-8'\n",
      "metadata": {
        "type": "code",
        "len": 645
      },
      "added": 1756647284.622716
    },
    {
      "doc_id": "app/db.py",
      "text": "FILE: app/db.py\nSUMMARY: Ce fichier Python configure une connexion \u00e0 une base de donn\u00e9es SQLite utilisant SQLAlchemy. Il d\u00e9finit les param\u00e8tres de connexion, cr\u00e9e un engine et une session locale, puis expose une fonction pour obtenir une instance de session qui peut \u00eatre utilis\u00e9e dans d'autres parties de l'application.\nCONTENT:\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\ndb_url = \"sqlite:///./test.db\"\necho_status = True\nengine = create_engine(db_url, connect_args={'check_same_thread': False}, echo=echo_status)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n",
      "metadata": {
        "type": "code",
        "len": 391
      },
      "added": 1756647173.6361737
    },
    {
      "doc_id": "tests/test_crud.py",
      "text": "FILE: tests/test_crud.py\nSUMMARY: {'file_name': 'tests/test_crud.py', 'description': 'This file contains test cases for CRUD operations in a FastAPI application using SQLAlchemy ORM.', 'endpoints': [{'path': '/products/', 'method': 'POST', 'description': 'Creates a new product.', 'input': 'ProductCreate', 'output': 'Created product'}, {'path': '/products/{product_id}', 'method': 'GET', 'description': 'Reads an existing product by ID.', 'input': 'product_id', 'output': 'Existing product or 404 error if not found'}, {'path': '/users/', 'method': 'POST', 'description': 'Creates a new user.', 'input': 'UserCreate', 'output': 'Created user'}], 'dependencies': ['FastAPI', 'HTTPException', 'CORSMiddleware', 'sqlalchemy', 'app.config.settings', 'app.db.get_db', 'app.crud.product_crud', 'app.crud.user_crud', 'app.schemas.ProductCreate', 'app.schemas.UserCreate']}\nCONTENT:\nfrom fastapi import FastAPI, HTTPException, Depends\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom app.config import settings\nfrom app.db import get_db\nfrom app.crud import product_crud, user_crud\nfrom app.schemas import ProductCreate, UserCreate\n\napp = FastAPI()\n\ncors_origins = [\n    \"*\",\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=cors_origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.post(\"/products/\")\ndef create_product(product: ProductCreate, db: Session = Depends(get_db)):\n    try:\n        return product_crud.create_product(db=db, product=product)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/products/{product_id}\")\ndef read_product(product_id: int, db: Session = Depends(get_db)):\n    try:\n        product = product_crud.get_product(db=db, product_id=product_id)\n        if not product:\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n        return product\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/users/\")\ndef create_user(user: UserCreate, db: Session = Depends(get_db)):\n    try:\n        return user_crud.create_user(db=db, user=user)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n",
      "metadata": {
        "type": "code",
        "len": 1429
      },
      "added": 1756645442.5282547
    },
    {
      "doc_id": ".env.example",
      "text": "FILE: .env.example\nSUMMARY: {\".env.example file contains environment variables for configuring a web application. It includes settings such as the database URL, secret key, algorithm for JWT tokens, and the expiration time in minutes for access tokens. The values provided are placeholders that need to be replaced with actual values before deployment. This file is typically used to keep sensitive information out of the codebase and allow easy configuration across different environments (development, testing, production). Examples include setting up a SQLite database, specifying a secret key for security purposes, configuring the algorithm used by JWT tokens, and defining how long access tokens should be valid before expiration. By keeping these configurations in separate environment files like .env.example, developers can easily manage different settings without modifying the codebase itself, enhancing both security and flexibility of the application setup across various stages of development and deployment. The placeholders (e.g., 'your-secret-key') indicate that actual values are required for production use to ensure the application is secure and functional. This file serves as a template for creating .env files tailored to specific environments by replacing these placeholder values with environment-specific data, facilitating a clean separation of configuration from code and enabling efficient deployment strategies. By following best practices in managing configuration files like this one, developers can improve the security and maintainability of their applications across different stages of development and deployment lifecycle.\": 'placeholder_values_required_for_production'}\nCONTENT:\nDB_URL=sqlite:///./test.db\nSECRET_KEY=your-secret-key\nALGORITHM=HS256\nACCESS_TOKEN_EXPIRE_MINUTES=30\n",
      "metadata": {
        "type": "code",
        "len": 101
      },
      "added": 1756645448.982259
    },
    {
      "doc_id": "success_1756645450_80",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 80/100\nPrompt: create a working commerce plateform with auth\nTech Stack: \nFiles Generated: 10\nArchitecture Pattern: MVC (Model-View-Controller)\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: []\n- Generated 10 files with score 80\n- Architecture: MVC (Model-View-Controller)\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\ngeneral_application\n\nTECH STACK EFFECTIVENESS:\nGood match: [] worked well for this type of project\n\nFILES CREATED:\nmain.py\napp/main.py\napp/models.py\napp/schemas.py\napp/crud.py\napp/config.py\napp/db.py\ntests/test_main.py\ntests/test_crud.py\n.env.example",
      "metadata": {
        "type": "knowledge",
        "score": 80,
        "tech_stack": [],
        "file_count": 10,
        "prompt_category": "general_application",
        "added": 1756645450.0746498
      },
      "added": 1756645450.0746498
    },
    {
      "doc_id": "app/routes/trading.py",
      "text": "FILE: app/routes/trading.py\nSUMMARY: This file defines routes for managing trading images using FastAPI. It includes endpoints for retrieving a list of trading images with pagination, creating a new trading image, retrieving a single trading image by ID, and updating an existing trading image. Each endpoint interacts with the database through SQLAlchemy ORM and utilizes services to perform business logic.\nCONTENT:\nfrom fastapi import APIRouter, Depends, HTTPException, Query\nfrom sqlalchemy.orm import Session\nfrom app.schemas import TradingImageCreate, TradingImageResponse, TradingImageUpdate\nfrom app.models import TradingImage\nfrom app.dependencies.db import get_db\nfrom app.services.trading_service import trading_service\n\nrouter = APIRouter()\n\n@router.get('/trading/', response_model=list[TradingImageResponse], summary='Get trading images with pagination', description='Retrieve a list of trading images with optional pagination')\ndef get_trading_images(db: Session = Depends(get_db), page: int = Query(1, ge=1), limit: int = Query(10, ge=1)):\n    return trading_service.get_trading_images(db, page, limit)\n\n@router.post('/trading/', response_model=TradingImageResponse, summary='Create a new trading image', description='Create a new trading image and return it')\ndef create_trading_image(trading_image: TradingImageCreate, db: Session = Depends(get_db)):\n    return trading_service.create_trading_image(db, trading_image)\n\n@router.get('/trading/{image_id}', response_model=TradingImageResponse, summary='Get a single trading image', description='Retrieve a single trading image by ID')\ndef get_trading_image(image_id: int, db: Session = Depends(get_db)):\n    return trading_service.get_trading_image(db, image_id)\n\n@router.put('/trading/{image_id}', response_model=TradingImageResponse, summary='Update an existing trading image', description='Update an existing trading image and return it')\ndef update_t",
      "metadata": {
        "type": "code",
        "len": 3743
      },
      "added": 1756646362.0380697
    },
    {
      "doc_id": "app/routes/comments.py",
      "text": "FILE: app/routes/comments.py\nSUMMARY: The `app/routes/comments.py` file contains FastAPI routes for managing comments in a database. It includes endpoints for creating, retrieving, updating, and deleting comments. The routes use dependency injection for the database session and interact with service functions to perform the actual operations on the comment data.\nCONTENT:\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom app.schemas.comment import CommentCreate, CommentUpdate, CommentResponse\nfrom app.models.comment import Comment\nfrom app.services.comment_service import get_comment_by_id, create_comment, update_comment, delete_comment, list_comments\nfrom app.dependencies.db import db_session\n\nrouter = APIRouter()\n\nclass PaginationParams:\n    page: int = 1\n    limit: int = 10\n\n@router.post('/comments/', response_model=CommentResponse)\ndef create_new_comment(comment: CommentCreate, db: Session = Depends(db_session)) -> CommentResponse:\n    return create_comment(comment, db)\n\n@router.get('/comments/{comment_id}', response_model=CommentResponse)\ndef read_comment_by_id(comment_id: int, db: Session = Depends(db_session)) -> CommentResponse:\n    comment = get_comment_by_id(comment_id, db)\n    if not comment:\n        raise HTTPException(status_code=404, detail='Comment not found')\n    return comment\n\n@router.put('/comments/{comment_id}', response_model=CommentResponse)\ndef update_comment_by_id(comment_id: int, comment_update: CommentUpdate, db: Session = Depends(db_session)) -> CommentResponse:\n    comment = get_comment_by_id(comment_id, db)\n    if not comment:\n        raise HTTPException(status_code=404, detail='Comment not found')\n    return update_comment(comment_id, comment_update, db)\n\n@router.delete('/comments/{comment_id}', status_code=204)\ndef delete_comment_by_id(comment_id: int, db: Session = Depe",
      "metadata": {
        "type": "code",
        "len": 2014
      },
      "added": 1756646364.6035683
    },
    {
      "doc_id": "app/services/trading_service.py",
      "text": "FILE: app/services/trading_service.py\nSUMMARY: Ce fichier contient la classe TradingService qui g\u00e8re les op\u00e9rations CRUD (Create, Read, Update, Delete) sur les objets TradingItem dans une base de donn\u00e9es SQL via SQLAlchemy ORM. La classe utilise un objet Session pour interagir avec la base de donn\u00e9es. Elle offre des m\u00e9thodes pour cr\u00e9er, r\u00e9cup\u00e9rer, mettre \u00e0 jour et supprimer des items de trading, tout en v\u00e9rifiant l'identit\u00e9 de l'utilisateur.\nCONTENT:\nfrom sqlalchemy.orm import Session\nfrom app.models import TradingItem, UserCart\nfrom app.schemas import TradingItemCreate, TradingItemUpdate\n\n\nclass TradingService:\n    def __init__(self, db: Session):\n        self.db = db\n\n    def create_trading_item(self, item: TradingItemCreate, user_id: int):\n        trading_item = TradingItem(**item.dict(), owner_id=user_id)\n        self.db.add(trading_item)\n        self.db.commit()\n        self.db.refresh(trading_item)\n        return trading_item\n\n    def get_trading_items(self, skip: int = 0, limit: int = 10):\n        return self.db.query(TradingItem).offset(skip).limit(limit).all()\n\n    def update_trading_item(self, item_id: int, item: TradingItemUpdate, user_id: int):\n        trading_item = self.db.query(TradingItem).filter(TradingItem.id == item_id, TradingItem.owner_id == user_id).first()\n        if not trading_item:\n            raise Exception('Item not found')\n        updated_data = item.dict(exclude_unset=True)\n        for key, value in updated_data.items():\n            setattr(trading_item, key, value)\n        self.db.commit()\n        self.db.refresh(trading_item)\n        return trading_item\n\n    def delete_trading_item(self, item_id: int, user_id: int):\n        trading_item = self.db.query(TradingItem).filter(TradingItem.id == item_id, TradingItem.owner_id == user_id).first()\n        if not trading_item:\n            raise Exception('Item not found')\n        self.db.delete(trading_item)\n        self.db.commit()\n\n    def add_to_",
      "metadata": {
        "type": "code",
        "len": 2329
      },
      "added": 1756646368.431367
    },
    {
      "doc_id": "app/services/comment_service.py",
      "text": "FILE: app/services/comment_service.py\nSUMMARY: {'file_name': 'app/services/comment_service.py', 'description': 'This file contains the CommentService class which provides methods for creating, retrieving, updating, and deleting comments in a trading application.', 'class': {'name': 'CommentService', 'methods': [{'name': '__init__', 'parameters': ['db: Session'], 'description': 'Initializes the CommentService with a database session.'}, {'name': 'create_comment', 'parameters': ['comment_data: CommentCreate', 'user_id: int'], 'returns': 'Comment', 'description': 'Creates a new comment for a trading item.'}, {'name': 'get_comments_by_trading_item_id', 'parameters': ['trading_item_id: int'], 'returns': 'list[Comment]', 'description': 'Retrieves all comments for a specific trading item.'}, {'name': 'update_comment', 'parameters': ['comment_id: int', 'comment_data: CommentUpdate'], 'returns': 'Comment', 'description': 'Updates an existing comment.'}, {'name': 'delete_comment', 'parameters': ['comment_id: int'], 'returns': 'None', 'description': 'Deletes a comment.'}]}, 'imports': [{'module': 'sqlalchemy.orm', 'imported_as': 'Session'}, {'module': 'app.models', 'imported_as': 'Comment'}, {'module': 'app.schemas', 'imported_as': ['CommentCreate', 'CommentUpdate']}, {'module': 'app.exceptions', 'imported_as': 'NotFoundError'}]}\nCONTENT:\nfrom sqlalchemy.orm import Session\nfrom app.models import Comment\nfrom app.schemas import CommentCreate, CommentUpdate\nfrom app.exceptions import NotFoundError\n\nclass CommentService:\n    def __init__(self, db: Session):\n        self.db = db\n\n    def create_comment(self, comment_data: CommentCreate, user_id: int) -> Comment:\n        '''\n        Create a new comment for a trading item.\n        '''\n        new_comment = Comment(**comment_data.dict(), user_id=user_id)\n        self.db.add(new_comment)\n        self.db.commit()\n        self.db.refresh(new_comment)\n        return new_comment\n\n    def get_comments_by_trading_item_id(self, trading_item_id: int) -> list[Comment]:\n        '''\n        Get all comments for a specific trading item.\n        '''\n        comments = self.db.query(Comment).filter(Comment.trading_item_id == trading_item_id).all()\n        return comments\n\n    def update_comment(self, comment_id: int, comment_data: CommentUpdate) -> Comment:\n        '''\n        Update an existing comment.\n        '''\n        comment = self.db.query(Comment).filter(Comment.id == comment_id).first()\n        if not comment:\n            raise NotFoundError('Comment not found')\n        for attr, value in comment_data.dict().items():\n            setattr(comment, attr, value)\n        self.db.commit()\n        self.db.refresh(comment)\n        return comment\n\n    def delete_comment(self, comment_id: int) -> None:\n        '''\n        Delete a comment.\n        '''\n        comment = self.db.que",
      "metadata": {
        "type": "code",
        "len": 1991
      },
      "added": 1756646382.5554764
    },
    {
      "doc_id": "app/dependencies/db.py",
      "text": "FILE: app/dependencies/db.py\nSUMMARY: Ce fichier Python d\u00e9finit les d\u00e9pendances pour la base de donn\u00e9es SQL dans une application. Il utilise SQLAlchemy, une biblioth\u00e8que ORM pour Python, pour g\u00e9rer les connexions \u00e0 la base de donn\u00e9es SQLite et la cr\u00e9ation d'objets de session. La connexion est \u00e9tablie avec le fichier de base de donn\u00e9es `test.db` et l'\u00e9cho des requ\u00eates est activ\u00e9. Une session locale est cr\u00e9\u00e9e et utilis\u00e9e pour ex\u00e9cuter des requ\u00eates, qui est ensuite ferm\u00e9e correctement.\nCONTENT:\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\ndb_url = \"sqlite:///./test.db\"\necho = True\nengine = create_engine(\n    db_url,\n    connect_args={},\n    echo=echo,\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n",
      "metadata": {
        "type": "code",
        "len": 448
      },
      "added": 1756646386.9625006
    },
    {
      "doc_id": "app/tests/conftest.py",
      "text": "FILE: app/tests/conftest.py\nSUMMARY: Ce fichier contient des configurations et d\u00e9finitions pour un test d'application utilisant SQLAlchemy comme ORM. Il inclut la cr\u00e9ation d'une base de donn\u00e9es SQLite, des classes de mod\u00e8le (Trading et Comment) d\u00e9finissant la structure de la base de donn\u00e9es, ainsi que des fixtures pytest pour g\u00e9rer la session de base de donn\u00e9es et nettoyer les tables apr\u00e8s les tests.\nCONTENT:\nimport pytest\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship, sessionmaker\ndb_url = \"sqlite:///test_db.db\"\necho_mode = False\nengine = create_engine(db_url, connect_args={}, echo=echo_mode)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\nclass Trading(Base):\n    __tablename__ = \"trading\"\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, index=True)\n    description = Column(String, index=True)\nclass Comment(Base):\n    __tablename__ = \"comments\"\n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(String, index=True)\n    trading_id = Column(Integer, ForeignKey(\"trading.id\"))\n    trading = relationship(\"Trading\", back_populates=\"comments\")\nTrading.comments = relationship(\"Comment\", order_by=Comment.id, back_populates=\"trading\")\ndef override_get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n@pytest.fixture(scope=\"module\")\ndef test_db(request):\n    Base.metadata.create_all(bind=engine)\n    def drop_tables(engine):\n        Base.metadata.drop_all(bind=engine)\n    request.addfinalizer(drop_tables, engine)\n    return engine\n@pytest.fixture(scope=\"module\")\ndef db(test_db):\n    return override_get_db()\n",
      "metadata": {
        "type": "code",
        "len": 1379
      },
      "added": 1756646390.4023447
    },
    {
      "doc_id": "app/tests/test_trading.py",
      "text": "FILE: app/tests/test_trading.py\nSUMMARY: Ce fichier `test_trading.py` d\u00e9finit des routes pour g\u00e9rer les op\u00e9rations CRUD (Create, Read, Update, Delete) sur des posts de trading dans une API FastAPI. Il utilise SQLAlchemy comme ORM pour interagir avec la base de donn\u00e9es. Les fonctions correspondent \u00e0 des services d\u00e9finis dans `trading_service.py`. Les endpoints permettent de cr\u00e9er un nouveau post de trading, lire tous les posts, lire un post sp\u00e9cifique par ID, mettre \u00e0 jour un post existant et supprimer un post.\nCONTENT:\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom app.dependencies.db import get_db\nfrom app.models.trading import TradingPost\nfrom app.schemas.trading import TradingPostCreate, TradingPostUpdate\nfrom app.services.trading_service import trading_post_create, trading_post_read_all, trading_post_read_by_id, trading_post_update, trading_post_delete\n\nrouter = APIRouter()\n\n@router.post('/trading/', response_model=TradingPost)\ndef create_trading_post(trading_post: TradingPostCreate, db: Session = Depends(get_db)):\n    return trading_post_create(db, trading_post)\n\n@router.get('/trading/', response_model=list[TradingPost])\ndef read_all_trading_posts(skip: int = 0, limit: int = 10, db: Session = Depends(get_db)):\n    return trading_post_read_all(db, skip=skip, limit=limit)\n\n@router.get('/trading/{post_id}', response_model=TradingPost)\ndef read_trading_post_by_id(post_id: int, db: Session = Depends(get_db)):\n    post = trading_post_read_by_id(db, post_id=post_id)\n    if not post:\n        raise HTTPException(status_code=404, detail='Trading post not found')\n    return post\n\n@router.put('/trading/{post_id}', response_model=TradingPost)\ndef update_trading_post(post_id: int, trading_post_update: TradingPostUpdate, db: Session = Depends(get_db)):\n    updated_post = trading_post_update(db, post_id=post_id, trading_post_update=trading_post_update)\n    if not updated_post:\n        raise HTTPException(status_code=404, detail='Trading post not found')\n ",
      "metadata": {
        "type": "code",
        "len": 1841
      },
      "added": 1756646394.7515228
    },
    {
      "doc_id": "success_1756646400_80",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 80/100\nPrompt: create a working trading image board with comments\nTech Stack: \nFiles Generated: 12\nArchitecture Pattern: MVC (Model-View-Controller)\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: []\n- Generated 12 files with score 80\n- Architecture: MVC (Model-View-Controller)\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\ngeneral_application\n\nTECH STACK EFFECTIVENESS:\nGood match: [] worked well for this type of project\n\nFILES CREATED:\napp/main.py\napp/config.py\napp/models.py\napp/schemas.py\napp/routes/trading.py\napp/routes/comments.py\napp/services/trading_service.py\napp/services/comment_service.py\napp/dependencies/db.py\napp/tests/conftest.py",
      "metadata": {
        "type": "knowledge",
        "score": 80,
        "tech_stack": [],
        "file_count": 12,
        "prompt_category": "general_application",
        "added": 1756646400.2223215
      },
      "added": 1756646400.2223215
    },
    {
      "doc_id": "app/auth.py",
      "text": "FILE: app/auth.py\nSUMMARY: This file contains authentication-related functions for a FastAPI application using OAuth2 and JWT tokens. It includes password hashing, token creation and validation, user authentication, and dependency injection for database sessions.\nCONTENT:\nfrom fastapi import HTTPException, Depends\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\nfrom jose import JWTError, jwt\nfrom sqlalchemy.orm import Session\nfrom app.config import settings\nfrom app.models import User\nfrom app.db import get_db\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# JWT token creation and validation\n\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n\nasync def authenticate_user(username: str, password: str, db: Session = Depends(get_db)):\n    user = db.query(User).filter(User.username == username).first()\n    if not user or not verify_password(password, user.password):\n        return False\n    return user\n\ndef create_access_token(data: dict, expires_delta: timedelta | None = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)\n    return encoded_jwt\n\nasync def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):\n    credentials_exception = HTTPExcepti",
      "metadata": {
        "type": "code",
        "len": 2420
      },
      "added": 1756647174.7583175
    },
    {
      "doc_id": "app/routers/user.py",
      "text": "FILE: app/routers/user.py\nSUMMARY: from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom app import schemas, models, crud, security\nclass UserNotFound(HTTPException):\n    def __init__(sel\nCONTENT:\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom app import schemas, models, crud, security\nclass UserNotFound(HTTPException):\n    def __init__(self):\n        super().__init__(status_code=status.HTTP_404_NOT_FOUND,\n                         detail=\"User not found\")\ndef get_db():\n    db = crud.get_db()\n    try:\n        yield db\n    finally:\n        db.close()@app.post('/register', response_model=schemas.User)\ndef register_user(user: schemas.UserCreate, db: Session = Depends(get_db)):\n    hashed_password = security.get_password_hash(user.password)\n    db_user = crud.get_user_by_email(db=db, email=user.email)\n    if db_user:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,\n                            detail=\"Email already registered\")\n    return crud.create_user(db=db, user=user, hashed_password=hashed_password)@app.post('/login', response_model=schemas.Token)\ndef login_for_access_token(form_data: schemas.LoginForm, db: Session = Depends(get_db)):\n    user = crud.get_user_by_email(db, form_data.username)\n    if not user or not security.verify_password(form_data.password, user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    access_token_expires = timedelta(minutes=security.ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = security.create_acce",
      "metadata": {
        "type": "code",
        "len": 1525
      },
      "added": 1756647182.5289564
    },
    {
      "doc_id": "app/routers/blog.py",
      "text": "FILE: app/routers/blog.py\nSUMMARY: This file contains API routes for managing blog posts using FastAPI and SQLAlchemy. It includes endpoints to create, read, and update blog posts, each requiring authentication through a token. The routes depend on database sessions provided by the `get_db` dependency and validate user permissions with the `verify_token` dependency.\nCONTENT:\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom app.config import get_db\nfrom app.models import BlogPost\nfrom app.schemas import BlogPostCreate, BlogPostUpdate\nfrom app.auth import verify_token\n\nrouter = APIRouter()\n\n@router.post('/blog', response_model=BlogPost)\nasync def create_blog_post(\n    blog_post: BlogPostCreate,\n    db: Session = Depends(get_db),\n    token_data: dict = Depends(verify_token)\n):\n    new_post = BlogPost(**blog_post.dict())\n    db.add(new_post)\n    db.commit()\n    db.refresh(new_post)\n    return new_post\n\n@router.get('/blog/{post_id}', response_model=BlogPost)\nasync def read_blog_post(\n    post_id: int,\n    db: Session = Depends(get_db),\n    token_data: dict = Depends(verify_token)\n):\n    blog_post = db.query(BlogPost).filter(BlogPost.id == post_id).first()\n    if not blog_post:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Blog post not found')\n    return blog_post\n\n@router.put('/blog/{post_id}', response_model=BlogPost)\nasync def update_blog_post(\n    post_id: int,\n    blog_post_update: BlogPostUpdate,\n    db: Session = Depends(get_db),\n    token_data: dict = Depends(verify_token)\n):\n    blog_post = db.query(BlogPost).filter(BlogPost.id == post_id).first()\n    if not blog_post:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Blog post not found')\n    for field, value in blog_post_update.dict(exclude_unset=True).items():\n        setattr(blog_pos",
      "metadata": {
        "type": "code",
        "len": 2018
      },
      "added": 1756647184.0405412
    },
    {
      "doc_id": "app/routers/comments.py",
      "text": "FILE: app/routers/comments.py\nSUMMARY: Ce fichier contient des routes pour g\u00e9rer les commentaires dans une application FastAPI. Il inclut les fonctionnalit\u00e9s suivantes : cr\u00e9ation d'un commentaire, r\u00e9cup\u00e9ration d'un commentaire par son ID et mise \u00e0 jour d'un commentaire par son ID. L'authentification est requise pour la cr\u00e9ation et la mise \u00e0 jour de commentaires.\nCONTENT:\nfrom fastapi import APIRouter, Depends, HTTPException, Path, status\nfrom sqlalchemy.orm import Session\nfrom app.db import get_db\nfrom app.schemas import CommentCreate, CommentResponse, CommentUpdate\nfrom app.models import Comment, User\nfrom app.auth import get_current_user\nfrom typing import List\n\nrouter = APIRouter(prefix=\"/comments\", tags=[\"Comments\"])\n\n@router.post(\"/\")\ndef create_comment(\n    comment: CommentCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    new_comment = Comment(**comment.dict(), user_id=current_user.id)\n    db.add(new_comment)\n    db.commit()\n    db.refresh(new_comment)\n    return CommentResponse.from_orm(new_comment)\n\n@router.get(\"/{comment_id}\")\ndef get_comment(\n    comment_id: int = Path(..., gt=0),\n    db: Session = Depends(get_db)\n):\n    comment = db.query(Comment).filter(Comment.id == comment_id).first()\n    if not comment:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Comment not found\")\n    return CommentResponse.from_orm(comment)\n\n@router.put(\"/{comment_id}\")\ndef update_comment(\n    comment_id: int = Path(..., gt=0),\n    comment_update: CommentUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    comment = db.query(Comment).filter(Comment.id == comment_id, Comment.user_id == current_user.id).first()\n    if not comment:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Comment not found\")\n    for ",
      "metadata": {
        "type": "code",
        "len": 2449
      },
      "added": 1756647185.6506913
    },
    {
      "doc_id": "tests/test_auth.py",
      "text": "FILE: tests/test_auth.py\nSUMMARY: {'file_name': 'tests/test_auth.py', 'description': 'This file contains unit tests for the authentication functionality of a FastAPI application.', 'test_cases': [{'name': 'test_login', 'description': 'Tests successful login with correct credentials.', 'expected_status_code': 200, 'assertions': [\"Response contains 'access_token'\", \"Response contains 'token_type'\"]}, {'name': 'test_invalid_login', 'description': 'Tests failed login with incorrect password.', 'expected_status_code': 401, 'assertions': [\"Response JSON is {'detail': 'Incorrect username or password'}\"]}]}\nCONTENT:\nimport pytest\nfrom fastapi.testclient import TestClient\nclass TestAuth:\n    def test_login(self, client):\n        response = client.post(\n            '/auth/login',\n            json={'username': 'testuser', 'password': 'testpass'}\n        )\n        assert response.status_code == 200\n        assert 'access_token' in response.json()\n        assert 'token_type' in response.json()\n\n    def test_invalid_login(self, client):\n        response = client.post(\n            '/auth/login',\n            json={'username': 'testuser', 'password': 'wrongpass'}\n        )\n        assert response.status_code == 401\n        assert response.json() == {'detail': 'Incorrect username or password'}\n",
      "metadata": {
        "type": "code",
        "len": 681
      },
      "added": 1756647189.7197795
    },
    {
      "doc_id": "tests/test_blog.py",
      "text": "FILE: tests/test_blog.py\nSUMMARY: Ce fichier contient des tests asynchrones pour la gestion des blog posts dans une application web. Les tests incluent la cr\u00e9ation, la mise \u00e0 jour et la suppression de blog posts. Chaque test utilise un client HTTP pour envoyer des requ\u00eates aux endpoints correspondants et v\u00e9rifie les r\u00e9ponses renvoy\u00e9es par le serveur. Des assertions sont utilis\u00e9es pour s'assurer que les op\u00e9rations CRUD sur les blog posts fonctionnent correctement en interagissant avec la base de donn\u00e9es.\nCONTENT:\nimport pytest\nfrom app.models import BlogPost\nfrom app.db import get_db\nfrom app.routers.blog import create_blog_post, update_blog_post, delete_blog_post\n\n@pytest.mark.asyncio\ndef test_create_blog_post(client, db):\n    data = {\n        'title': 'Test Title',\n        'content': 'This is a test blog post.'\n    }\n    response = client.post('/blog/', json=data)\n    assert response.status_code == 201\n    created_post = response.json()\\n    assert BlogPost.get(db, created_post['id'])\n\n@pytest.mark.asyncio\ndef test_update_blog_post(client, db):\n    original_data = {\n        'title': 'Original Title',\n        'content': 'This is the original blog post.'\n    }\n    response = client.post('/blog/', json=original_data)\n    assert response.status_code == 201\n    created_post = response.json()\n    updated_data = {\n        'title': 'Updated Title',\n        'content': 'This is the updated blog post.'\n    }\n    response = client.put(f'/blog/{created_post['id']}', json=updated_data)\n    assert response.status_code == 200\n    updated_post = response.json()\n    assert updated_post['title'] == updated_data['title']\n    assert updated_post['content'] == updated_data['content']\n\n@pytest.mark.asyncio\ndef test_delete_blog_post(client, db):\n    data = {\n        'title': 'Test Title',\n        'content': 'This is a test blog post.'\n    }\n    response = client.post('/blog/', json=data)\n    assert response.status_code == 201\n    created_post = response.json()\n    response = client.delete(f'/blog/{created_",
      "metadata": {
        "type": "code",
        "len": 1695
      },
      "added": 1756647191.9697683
    },
    {
      "doc_id": "success_1756647202_84",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 84/100\nPrompt: Create a blog platform with user authentication and comments\nTech Stack: fastapi, pydantic, sqlalchemy, jwtauth, uvicorn\nFiles Generated: 15\nArchitecture Pattern: fastapi_project_structure\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: ['fastapi', 'pydantic', 'sqlalchemy', 'jwtauth', 'uvicorn']\n- Generated 15 files with score 84\n- Architecture: fastapi_project_structure\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\ncontent_management\n\nTECH STACK EFFECTIVENESS:\nGood match: ['fastapi', 'pydantic', 'sqlalchemy', 'jwtauth', 'uvicorn'] worked well for this type of project\n\nFILES CREATED:\nmain.py\napp/config.py\napp/models.py\napp/db.py\napp/auth.py\napp/routers/user.py\napp/routers/blog.py\napp/routers/comments.py\ntests/test_main.py\ntests/test_auth.py",
      "metadata": {
        "type": "knowledge",
        "score": 84,
        "tech_stack": [
          "fastapi",
          "pydantic",
          "sqlalchemy",
          "jwtauth",
          "uvicorn"
        ],
        "file_count": 15,
        "prompt_category": "content_management",
        "added": 1756647202.632077
      },
      "added": 1756647202.632077
    },
    {
      "doc_id": "app/db/models.py",
      "text": "FILE: app/db/models.py\nSUMMARY: {'file_name': 'app/db/models.py', 'description': 'This file contains the SQLAlchemy models for a simple user and task management system.', 'classes': [{'name': 'User', 'description': 'Represents a user with attributes such as username, email, and hashed password. It has a one-to-many relationship with tasks.', 'attributes': ['id (Integer, primary_key)', 'username (String, unique, index, nullable=False)', 'email (String, unique, index, nullable=False)', 'hashed_password (String, nullable=False)'], 'methods': ['__repr__ (returns a string representation of the user object)']}, {'name': 'Task', 'description': 'Represents a task with attributes such as title, description, due_date, and completion status. It belongs to a user.', 'attributes': ['id (Integer, primary_key)', 'title (String, nullable=False)', 'description (String)', 'due_date (DateTime, default=datetime.utcnow)', 'completed (Boolean, default=False)', \"user_id (Integer, ForeignKey('users.id'), nullable=False)\"], 'methods': ['__repr__ (returns a string representation of the task object)']}]}\nCONTENT:\nfrom sqlalchemy import Column, Integer, String, ForeignKey, DateTime\nfrom sqlalchemy.orm import relationship, backref\nfrom datetime import datetime\nfrom app.db.session import Base\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True)\n    username = Column(String(50), unique=True, index=True, nullable=False)\n    email = Column(String(120), unique=True, index=True, nullable=False)\n    hashed_password = Column(String(255), nullable=False)\n\n    tasks = relationship('Task', backref=backref('owner', lazy='dynamic'))\n\n    def __repr__(self):\n        return f'<User {self.username}>'\n\nclass Task(Base):\n    __tablename__ = 'tasks'\n    id = Column(Integer, primary_key=True)\n    title = Column(String(100), nullable=False)\n    description = Column(String(500))\n    due_date = Column(DateTime, default=datetime.utcnow)\n    completed = Column(Boolean, default=False)\n\n    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)\n\n    def __repr__(self):\n        return f'<Task {self.title}>'\n",
      "metadata": {
        "type": "code",
        "len": 1032
      },
      "added": 1756647289.7599542
    },
    {
      "doc_id": "app/db/session.py",
      "text": "FILE: app/db/session.py\nSUMMARY: Ce fichier Python d\u00e9finit une session de base de donn\u00e9es asynchrone utilisant SQLAlchemy. Il cr\u00e9e un engine pour la connexion \u00e0 une base de donn\u00e9es PostgreSQL et utilise une session factory pour g\u00e9n\u00e9rer des sessions async. La fonction `get_db` est une g\u00e9n\u00e9rateur qui permet d'obtenir une session de base de donn\u00e9es et de s'en d\u00e9barrasser correctement lorsqu'elle n'est plus n\u00e9cessaire.\nCONTENT:\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker\ndb_url = \"postgresql+asyncpg://username:password@localhost/dbname\"\nengine = create_async_engine(db_url, future=True)\nsession_factory = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\ndef get_db():\n    async with session_factory() as db:\n        try:\n            yield db\n        finally:\n            await db.close()\n",
      "metadata": {
        "type": "code",
        "len": 444
      },
      "added": 1756648896.8632421
    },
    {
      "doc_id": "app/auth/jwt_auth.py",
      "text": "FILE: app/auth/jwt_auth.py\nSUMMARY: This Python file contains authentication functionality using JWT (JSON Web Tokens) with FastAPI. It includes components for token creation, verification, and dependency injection to fetch the current user.\nCONTENT:\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom jose import JWTError, jwt\nfrom datetime import datetime, timedelta\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Session\nfrom app.config import Settings\nfrom app.db.models import User\nfrom app.services.user_service import get_user_by_email\n\nsettings = Settings()\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\nclass TokenData(BaseModel):\n    username: str | None = None\ndef create_access_token(data: dict, expires_delta: timedelta | None = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)\n    return encoded_jwt\ndef verify_token(token: str, credentials_exception):\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\ndef get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate cre",
      "metadata": {
        "type": "code",
        "len": 1819
      },
      "added": 1756647292.3302846
    },
    {
      "doc_id": "app/services/task_service.py",
      "text": "FILE: app/services/task_service.py\nSUMMARY: {'class_name': 'TaskService', 'description': 'A service class for managing tasks using SQLAlchemy ORM.', 'methods': [{'name': '__init__', 'parameters': ['db: Session'], 'description': 'Initializes the TaskService with a database session.'}, {'name': 'create_task', 'parameters': ['task_data: TaskCreate'], 'return_type': 'Task', 'description': 'Creates a new task in the database and returns it.'}, {'name': 'get_task', 'parameters': ['task_id: int'], 'return_type': 'Optional[Task]', 'description': 'Retrieves a task by its ID from the database.'}, {'name': 'update_task', 'parameters': ['task_id: int', 'task_data: TaskUpdate'], 'return_type': 'Optional[Task]', 'description': 'Updates an existing task with new data. Raises an HTTPException if the task is not found.'}, {'name': 'delete_task', 'parameters': ['task_id: int'], 'return_type': 'bool', 'description': 'Deletes a task from the database and returns True if successful.'}]}\nCONTENT:\nfrom sqlalchemy.orm import Session\nfrom typing import List, Optional\nfrom app.db.models import Task\nfrom app.schemas.task_schema import TaskCreate, TaskUpdate\nfrom fastapi.exceptions import HTTPException\nfrom datetime import datetime\n\nclass TaskService:\n    def __init__(self, db: Session):\n        self.db = db\n\n    def create_task(self, task_data: TaskCreate) -> Task:\n        new_task = Task(\n            title=task_data.title,\n            description=task_data.description,\n            due_date=task_data.due_date,\n            created_at=datetime.now(),\n            updated_at=datetime.now()\n        )\n        self.db.add(new_task)\n        self.db.commit()\n        self.db.refresh(new_task)\n        return new_task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        task = self.db.query(Task).filter(Task.id == task_id).first()\n        return task\n\n    def update_task(self, task_id: int, task_data: TaskUpdate) -> Optional[Task]:\n        task = self.db.query(Task).filter(Task.id == task_id).first()\n        if not task:\n            raise HTTPException(status_code=404, detail=\"Task not found\")\n\n        task.title = task_data.title or task.title\n        task.description = task_data.description or task.description\n        task.due_date = task_data.due_date or task.due_date\n        task.updated_at = datetime.now()\n        self.db.commit()\n        self.db.refresh(task)\n        return task\n\n    def delete_task(self, task_id: int) -> bool:\n        task = self.db.query(Task).filt",
      "metadata": {
        "type": "code",
        "len": 1808
      },
      "added": 1756647297.3780777
    },
    {
      "doc_id": "app/routes/task_routes.py",
      "text": "FILE: app/routes/task_routes.py\nSUMMARY: Ce fichier contient des routes FastAPI pour g\u00e9rer les t\u00e2ches (tasks). Il d\u00e9finit les m\u00e9thodes CRUD pour cr\u00e9er, lire, mettre \u00e0 jour et supprimer des t\u00e2ches. Chaque route utilise un service sp\u00e9cifique pour effectuer l'op\u00e9ration correspondante en utilisant une session de base de donn\u00e9es. Les exceptions sont g\u00e9r\u00e9es pour renvoyer des erreurs appropri\u00e9es si n\u00e9cessaire.\nCONTENT:\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom app.config import get_settings\nfrom app.db.session import get_db\nfrom app.db.models.task import Task\nfrom app.schemas.task import TaskCreate, TaskUpdate, TaskResponse\nfrom app.services.task_service import create_task, get_tasks, get_task, update_task, delete_task\nfrom fastapi.responses import JSONResponse\ntask_router = APIRouter()\n@task_router.post('/tasks/', response_model=TaskResponse)\ndef create_new_task(task: TaskCreate, db: Session = Depends(get_db), settings: Settings = Depends(get_settings)):\n    try:\n        return create_task(db=db, task=task)\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))\n@task_router.get('/tasks/', response_model=list[TaskResponse])\ndef read_tasks(skip: int = 0, limit: int = 10, db: Session = Depends(get_db), settings: Settings = Depends(get_settings)):\n    tasks = get_tasks(db=db, skip=skip, limit=limit)\n    return tasks\n@task_router.get('/tasks/{task_id}', response_model=TaskResponse)\ndef read_task(task_id: int, db: Session = Depends(get_db), settings: Settings = Depends(get_settings)):\n    task = get_task(db=db, task_id=task_id)\n    if not task:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Task not found')\n    return task\n@task_router.put('/tasks/{task_id}', response_model=TaskResponse)\ndef update_task_route(task_id: int, task_update: TaskUpdate, db: Se",
      "metadata": {
        "type": "code",
        "len": 2188
      },
      "added": 1756647299.202663
    },
    {
      "doc_id": "app/middleware/cors_middleware.py",
      "text": "FILE: app/middleware/cors_middleware.py\nSUMMARY: Ce fichier Python d\u00e9finit un middleware CORS personnalis\u00e9 pour une application FastAPI. Le middleware utilise la classe `CORSMiddleware` de FastAPI et configure les param\u00e8tres suivants : allow_origins, allow_credentials, allow_methods et allow_headers. Il intercepte les requ\u00eates entrantes et sortantes pour ajouter les en-t\u00eates CORS appropri\u00e9s.\nCONTENT:\nfrom fastapi import Request, Response\nfrom fastapi.middleware.cors import CORSMiddleware\n\n\nclass CORSMiddleware:\n    def __init__(self, app):\n        self.app = app\n        self.cors_middleware = CORSMiddleware(\n            app=self.app,\n            allow_origins=[\"*\"],\n            allow_credentials=True,\n            allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"],\n            allow_headers=[\"*\"],\n        )\n\n    async def __call__(self, request: Request, call_next):\n        response = await self.cors_middleware(request, call_next)\n        return response\n",
      "metadata": {
        "type": "code",
        "len": 571
      },
      "added": 1756647300.702959
    },
    {
      "doc_id": "tests/test_task_routes.py",
      "text": "FILE: tests/test_task_routes.py\nSUMMARY: {'file_name': 'tests/test_task_routes.py', 'description': 'This file contains the routes for managing tasks in a FastAPI application. It includes endpoints for creating, retrieving, updating, and deleting tasks.', 'endpoints': [{'path': '/tasks/', 'method': 'POST', 'description': 'Creates a new task.'}, {'path': '/tasks/', 'method': 'GET', 'description': 'Retrieves all tasks with optional pagination parameters.'}, {'path': '/tasks/{task_id}', 'method': 'GET', 'description': 'Retrieves a task by its ID. Raises an exception if the task is not found.'}, {'path': '/tasks/{task_id}', 'method': 'PUT', 'description': 'Updates a task by its ID. Raises an exception if the task is not found.'}, {'path': '/tasks/{task_id}', 'method': 'DELETE', 'description': 'Deletes a task by its ID. Returns 204 No Content if successful, raises an exception if the task is not found.'}], 'dependencies': ['FastAPI', 'SQLAlchemy', 'app.db.session.get_db', 'app.db.models.task.Task', 'app.schemas.task_schema.TaskCreate', 'app.schemas.task_schema.TaskUpdate', 'app.schemas.task_schema.TaskOut', 'app.services.task_service.task_service']}\nCONTENT:\nfrom fastapi import FastAPI, Depends, HTTPException, status from sqlalchemy.orm import Session from app.db.session import get_db from app.db.models.task import Task from app.schemas.task_schema import TaskCreate, TaskUpdate, TaskOut from app.services.task_service import task_service\n\napp = FastAPI()\n\n@app.post('/tasks/', response_model=TaskOut)\ndef create_task(task: TaskCreate, db: Session = Depends(get_db)):\n    return task_service.create_task(db, task)\n\n@app.get('/tasks/', response_model=list[TaskOut])\ndef read_tasks(skip: int = 0, limit: int = 10, db: Session = Depends(get_db)):\n    return task_service.get_tasks(db, skip=skip, limit=limit)\n\n@app.get('/tasks/{task_id}', response_model=TaskOut)\ndef read_task(task_id: int, db: Session = Depends(get_db)):\n    task = task_service.get_task_by_id(db, task_id)\n    if not task:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Task not found')\n    return task\n\n@app.put('/tasks/{task_id}', response_model=TaskOut)\ndef update_task(task_id: int, task: TaskUpdate, db: Session = Depends(get_db)):\n    updated_task = task_service.update_task(db, task_id, task)\n    if not updated_task:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Task not found')\n    return updated_task\n\n@app.delete('/tasks/{task_id}', status_code=status.HTTP_204_NO_CONTENT)\ndef delete_task(task_id: int, db: Session = Depends(get_db)):\n    deleted_task = task_service.delete_task(db, task_id)\n    if not deleted_task:\n   ",
      "metadata": {
        "type": "code",
        "len": 1589
      },
      "added": 1756647308.3115008
    },
    {
      "doc_id": "app/models/task.py",
      "text": "FILE: app/models/task.py\nSUMMARY: from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Boolean, Text\nfrom sqlalchemy.orm import relationship, backref\nfrom app.db.base_model import Base\nfrom datetime import datetime\n\nc\nCONTENT:\nfrom sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Boolean, Text\nfrom sqlalchemy.orm import relationship, backref\nfrom app.db.base_model import Base\nfrom datetime import datetime\n\nclass Task(Base):\n    __tablename__ = \"task\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String(255), nullable=False)\n    description = Column(Text, nullable=True)\n    start_date = Column(DateTime, default=datetime.utcnow)\n    end_date = Column(DateTime, nullable=True)\n    is_completed = Column(Boolean, default=False)\n    project_id = Column(Integer, ForeignKey(\"project.id\"), index=True)\n\n    project = relationship(\"Project\", backref=backref(\"tasks\", lazy=True))\n\n    dependencies = relationship(\"TaskDependency\", foreign_keys=[\"dependency_id\"], lazy=\"subquery\")\n    dependents = relationship(\"TaskDependency\", foreign_keys=[\"dependent_id\"], lazy=\"subquery\")\n\n    __repr__ = lambda self: f'<Task(id={self.id}, title={self.title})>'\n",
      "metadata": {
        "type": "code",
        "len": 966
      },
      "added": 1756648904.076134
    },
    {
      "doc_id": "app/routes/tasks.py",
      "text": "FILE: app/routes/tasks.py\nSUMMARY: Ce fichier Python d\u00e9finit des routes FastAPI pour g\u00e9rer les t\u00e2ches. Il inclut une classe de mod\u00e8le `Task` utilisant Pydantic et une liste interne `_db` pour stocker les donn\u00e9es des t\u00e2ches. Les routes disponibles sont : \n\n- POST `/tasks`: Cr\u00e9e une nouvelle t\u00e2che en g\u00e9n\u00e9rant un ID unique bas\u00e9 sur la longueur de la liste existante.\n- GET `/tasks`: Renvoie la liste compl\u00e8te des t\u00e2ches.\nCONTENT:\nfrom fastapi import APIRouter\nfrom pydantic import BaseModel\nrouter = APIRouter(prefix='/tasks', tags=['tasks'])\nclass Task(BaseModel):\n    id: int | None = None\n    name: str\n_db: list[Task] = []\n@router.post('/', response_model=Task)\nasync def create_task(data: Task):\n    data.id = len(_db)+1\n    _db.append(data)\n    return data\n@router.get('/', response_model=list[Task])\nasync def list_tasks():\n    return _db\n",
      "metadata": {
        "type": "code",
        "len": 416
      },
      "added": 1756648192.2473664
    },
    {
      "doc_id": "success_1756647319_85",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 85/100\nPrompt: Build a task management system for teams\nTech Stack: fastapi, pydantic, sqlalchemy, jwtauth, uvicorn\nFiles Generated: 14\nArchitecture Pattern: Clean Architecture\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: ['fastapi', 'pydantic', 'sqlalchemy', 'jwtauth', 'uvicorn']\n- Generated 14 files with score 85\n- Architecture: Clean Architecture\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\nadmin_interface\n\nTECH STACK EFFECTIVENESS:\nExcellent match: ['fastapi', 'pydantic', 'sqlalchemy', 'jwtauth', 'uvicorn'] produced high-quality results\n\nFILES CREATED:\nmain.py\napp/config.py\napp/db/models.py\napp/db/session.py\napp/auth/jwt_auth.py\napp/services/task_service.py\napp/routes/task_routes.py\napp/middleware/cors_middleware.py\ntests/conftest.py\ntests/test_task_routes.py",
      "metadata": {
        "type": "knowledge",
        "score": 85,
        "tech_stack": [
          "fastapi",
          "pydantic",
          "sqlalchemy",
          "jwtauth",
          "uvicorn"
        ],
        "file_count": 14,
        "prompt_category": "admin_interface",
        "added": 1756647319.0822706
      },
      "added": 1756647319.0822706
    },
    {
      "doc_id": "success_1756647410_90",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 90/100\nPrompt: Create a blog platform\nTech Stack: fastapi, pydantic, sqlalchemy, jwtauth, uvicorn\nFiles Generated: 6\nArchitecture Pattern: Clean Architecture\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: ['fastapi', 'pydantic', 'sqlalchemy', 'jwtauth', 'uvicorn']\n- Generated 6 files with score 90\n- Architecture: Clean Architecture\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\ncontent_management\n\nTECH STACK EFFECTIVENESS:\nExcellent match: ['fastapi', 'pydantic', 'sqlalchemy', 'jwtauth', 'uvicorn'] produced high-quality results\n\nFILES CREATED:\napp/main.py\napp/models/__init__.py\napp/routes/__init__.py\napp/schemas.py\ntests/__init__.py\napp/routes/health.py",
      "metadata": {
        "type": "knowledge",
        "score": 90,
        "tech_stack": [
          "fastapi",
          "pydantic",
          "sqlalchemy",
          "jwtauth",
          "uvicorn"
        ],
        "file_count": 6,
        "prompt_category": "content_management",
        "added": 1756647410.9570508
      },
      "added": 1756647410.9570508
    },
    {
      "doc_id": "success_1756648192_82",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 82/100\nPrompt: Create a blog platform with posts and comments\nTech Stack: \nFiles Generated: 5\nArchitecture Pattern: Clean Architecture\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: []\n- Generated 5 files with score 82\n- Architecture: Clean Architecture\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\ncontent_management\n\nTECH STACK EFFECTIVENESS:\nGood match: [] worked well for this type of project\n\nFILES CREATED:\napp/main.py\napp/models/__init__.py\napp/routes/__init__.py\napp/schemas.py\ntests/__init__.py",
      "metadata": {
        "type": "knowledge",
        "score": 82,
        "tech_stack": [],
        "file_count": 5,
        "prompt_category": "content_management",
        "added": 1756648192.1302555
      },
      "added": 1756648192.1302555
    },
    {
      "doc_id": "success_1756648192_90",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 90/100\nPrompt: Create a learning management system with courses\nTech Stack: fastapi, pydantic, sqlalchemy, jwtauth, uvicorn\nFiles Generated: 6\nArchitecture Pattern: Clean Architecture\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: ['fastapi', 'pydantic', 'sqlalchemy', 'jwtauth', 'uvicorn']\n- Generated 6 files with score 90\n- Architecture: Clean Architecture\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\nadmin_interface\n\nTECH STACK EFFECTIVENESS:\nExcellent match: ['fastapi', 'pydantic', 'sqlalchemy', 'jwtauth', 'uvicorn'] produced high-quality results\n\nFILES CREATED:\napp/main.py\napp/models/__init__.py\napp/routes/__init__.py\napp/schemas.py\ntests/__init__.py\napp/routes/health.py",
      "metadata": {
        "type": "knowledge",
        "score": 90,
        "tech_stack": [
          "fastapi",
          "pydantic",
          "sqlalchemy",
          "jwtauth",
          "uvicorn"
        ],
        "file_count": 6,
        "prompt_category": "admin_interface",
        "added": 1756648192.5999558
      },
      "added": 1756648192.5999558
    },
    {
      "doc_id": "success_1756648192_77",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 77/100\nPrompt: Create an e-commerce store with products and cart\nTech Stack: python, fastapi, sqlite\nFiles Generated: 6\nArchitecture Pattern: Clean Architecture\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: ['python', 'fastapi', 'sqlite']\n- Generated 6 files with score 77\n- Architecture: Clean Architecture\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\necommerce\n\nTECH STACK EFFECTIVENESS:\nGood match: ['python', 'fastapi', 'sqlite'] worked well for this type of project\n\nFILES CREATED:\napp/main.py\napp/models/__init__.py\napp/routes/__init__.py\napp/schemas.py\ntests/__init__.py\napp/routes/health.py",
      "metadata": {
        "type": "knowledge",
        "score": 77,
        "tech_stack": [
          "python",
          "fastapi",
          "sqlite"
        ],
        "file_count": 6,
        "prompt_category": "ecommerce",
        "added": 1756648192.3760312
      },
      "added": 1756648192.3760312
    },
    {
      "doc_id": "success_1756648192_78",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 78/100\nPrompt: Build a social media platform with posts and followers\nTech Stack: \nFiles Generated: 5\nArchitecture Pattern: Clean Architecture\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: []\n- Generated 5 files with score 78\n- Architecture: Clean Architecture\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\ngeneral_application\n\nTECH STACK EFFECTIVENESS:\nGood match: [] worked well for this type of project\n\nFILES CREATED:\napp/main.py\napp/models/__init__.py\napp/routes/__init__.py\napp/schemas.py\ntests/__init__.py",
      "metadata": {
        "type": "knowledge",
        "score": 78,
        "tech_stack": [],
        "file_count": 5,
        "prompt_category": "general_application",
        "added": 1756648192.484312
      },
      "added": 1756648192.484312
    },
    {
      "doc_id": "app/core/config.py",
      "text": "FILE: app/core/config.py\nSUMMARY: Ce fichier contient les routes FastAPI pour g\u00e9rer les projets. Il y a une route POST pour cr\u00e9er un nouveau projet et une route GET pour r\u00e9cup\u00e9rer un projet par son ID.\nCONTENT:\nfrom fastapi import APIRouter\nfrom app.models.project import Project\nfrom app.services.project_service import create_project, get_project_by_id\n\nproject_router = APIRouter()\n\n@project_router.post('/projects/', response_model=Project)\ndef create_project_route(project: Project):\n    try:\n        return create_project(project)\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))\n\n@project_router.get('/projects/{project_id}', response_model=Project)\ndef get_project_route(project_id: int):\n    try:\n        project = get_project_by_id(project_id)\n        if not project:\n            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Project not found')\n        return project\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))\n",
      "metadata": {
        "type": "code",
        "len": 882
      },
      "added": 1756648888.455905
    },
    {
      "doc_id": "app/core/security.py",
      "text": "FILE: app/core/security.py\nSUMMARY: Ce fichier contient des classes et fonctions pour la gestion de l'authentification et de la s\u00e9curit\u00e9 dans une application FastAPI. Il utilise OAuth2 avec JWT pour les tokens d'acc\u00e8s, Bcrypt pour le hachage du mot de passe et un sch\u00e9ma Pydantic pour les mod\u00e8les de donn\u00e9es.\nCONTENT:\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom passlib.context import CryptContext\nfrom jose import JWTError, jwt\nfrom datetime import datetime, timedelta\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nSECRET_KEY = \"your_secret_key\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\nclass TokenData(BaseModel):\n    username: Optional[str] = None\n    scopes: list = []\n\nclass User(BaseModel):\n    username: str\n    full_name: Optional[str] = None\n    email: Optional[str] = None\n    disabled: Optional[bool] = None\n\nclass UserInDB(User):\n    hashed_password: str\n\nfake_users_db = {\n    \"johndoe\":{\n        \"username\":\"johndoe\",\n        \"full_name\":\"John Doe\",\n        \"email\":\"johndoe@example.com\",\n        \"hashed_password\":pwd_context.hash(\"secret\")\n        }\n}\n\nasync def get_user(username: str):\n    if username in fake_users_db:\n        user_dict = fake_users_db[username]\n        return UserInDB(**user_dict)\n\nasync def verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\n\nasync def authenticate_user(username: str, password: str):\n    user = await get_user(username)\n    if not user:\n        return False\n    if not await verify_password(password, user.hashed_password):\n        return False\n",
      "metadata": {
        "type": "code",
        "len": 2787
      },
      "added": 1756648890.071143
    },
    {
      "doc_id": "app/db/base_model.py",
      "text": "FILE: app/db/base_model.py\nSUMMARY: {'file_name': 'app/db/base_model.py', 'description': \"This file contains the base model definition using SQLAlchemy's declarative_base, which is used to create table definitions.\", 'main_class': {'class_name': 'Base', 'description': 'A base class for all database models defined in this module.'}, 'example_model': {'model_name': 'User', 'table_name': 'users', 'fields': [{'name': 'id', 'type': 'Integer', 'attributes': ['primary_key', 'index']}, {'name': 'username', 'type': 'String', 'attributes': ['unique', 'index']}, {'name': 'email', 'type': 'String', 'attributes': ['unique', 'index']}, {'name': 'hashed_password', 'type': 'String'}], 'description': 'An example model representing a user with fields for id, username, email, and hashed password.'}, 'instructions': 'Additional tables and relationships can be added to this base model as needed for the application.'}\nCONTENT:\nfrom sqlalchemy.ext.declarative import declarative_base\nBase = declarative_base()\n\n# Example usage of Base model in a SQLAlchemy table\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String, unique=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n\n# Add more tables and relationships as needed for your application\n",
      "metadata": {
        "type": "code",
        "len": 448
      },
      "added": 1756648895.016868
    },
    {
      "doc_id": "app/models/project.py",
      "text": "FILE: app/models/project.py\nSUMMARY: Ce fichier contient les d\u00e9finitions de mod\u00e8les SQLAlchemy pour une application qui g\u00e8re des projets et leurs t\u00e2ches. Il inclut trois classes principales : Project, Workspace et Task. Le mod\u00e8le Project est li\u00e9 \u00e0 plusieurs Milestone et T\u00e2che via des relations. Les Workspaces peuvent contenir plusieurs Projets. Les T\u00e2ches sont li\u00e9es entre elles par des d\u00e9pendances d\u00e9finies dans une table interm\u00e9diaire project_task_dependency.\nCONTENT:\nfrom sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Table\nfrom sqlalchemy.orm import relationship, backref\ntable_project_task_dependency = Table('project_task_dependency', Column('project_id', Integer, ForeignKey('projects.id'), primary_key=True), Column('task_id', Integer, ForeignKey('tasks.id'), primary_key=True))\nclass Project(Base):\n    __tablename__ = 'projects'\n    id = Column(Integer, primary_key=True)\n    name = Column(String, index=True)\n    description = Column(String)\n    workspace_id = Column(Integer, ForeignKey('workspaces.id'))\n    milestones = relationship(\"Milestone\", backref=backref(\"project\", foreign_keys=[milestone.project_id]))\n    tasks = relationship(\"Task\", secondary=table_project_task_dependency, back_populates=\"projects\")\n\n    def __repr__(self):\n        return f'<Project {self.name}>'\nclass Workspace(Base):\n    __tablename__ = 'workspaces'\n    id = Column(Integer, primary_key=True)\n    name = Column(String, index=True)\n    projects = relationship(\"Project\", backref=backref(\"workspace\", foreign_keys=[project.workspace_id]))\n\n    def __repr__(self):\n        return f'<Workspace {self.name}>'\nclass Task(Base):\n    __tablename__ = 'tasks'\n    id = Column(Integer, primary_key=True)\n    name = Column(String, index=True)\n    description = Column(String)\n    start_date = Column(DateTime)\n    end_date = Column(DateTime)\n    duration = Column(Float)\n    project_id = Column(Integer, ForeignKey('projects.id'))\n    dependencies = relationship(\"Ta",
      "metadata": {
        "type": "code",
        "len": 2148
      },
      "added": 1756648899.0045404
    },
    {
      "doc_id": "app/services/project_service.py",
      "text": "FILE: app/services/project_service.py\nSUMMARY: The `app/services/project_service.py` file contains a `ProjectService` class that provides methods for interacting with projects in a database using SQLAlchemy and FastAPI. The class includes methods to get, create, update, and delete project records. It also uses dependency injection to obtain a database session from the `get_db` function.\nCONTENT:\nfrom app.core.config import settings\nfrom app.db.session import get_db\nfrom app.models.project import Project, Task\nfrom sqlalchemy.orm import Session\nfrom fastapi import HTTPException, Depends, APIRouter, status\n\nrouter = APIRouter()\n\nclass ProjectService:\n    def __init__(self, db: Session = Depends(get_db)) -> None:\n        self.db = db\n\n    def get_project_by_id(self, project_id: int) -> Project:\n        project = self.db.query(Project).filter(Project.id == project_id).first()\n        if not project:\n            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Project not found\")\n        return project\n\n    def create_project(self, title: str, description: str) -> Project:\n        new_project = Project(title=title, description=description)\n        self.db.add(new_project)\n        self.db.commit()\n        self.db.refresh(new_project)\n        return new_project\n\n    def update_project(self, project_id: int, title: str, description: str) -> Project:\n        project = self.db.query(Project).filter(Project.id == project_id).first()\n        if not project:\n            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Project not found\")\n        project.title = title\n        project.description = description\n        self.db.commit()\n        self.db.refresh(project)\n        return project\n\n    def delete_project(self, project_id: int) -> None:\n        project = self.db.query(Project).filter(Project.id == project_id).first()\n        if not projec",
      "metadata": {
        "type": "code",
        "len": 2847
      },
      "added": 1756648905.5116823
    },
    {
      "doc_id": "app/routers/project_router.py",
      "text": "FILE: app/routers/project_router.py\nSUMMARY: {'file_name': 'app/routers/project_router.py', 'description': 'This file defines a FastAPI router for handling project-related operations such as creating, retrieving, and updating projects. It uses dependency injection for database sessions and token verification.', 'routes': [{'method': 'POST', 'path': '/projects', 'response_model': 'ProjectCreate', 'description': 'Creates a new project.'}, {'method': 'GET', 'path': '/projects/{project_id}', 'response_model': 'Project', 'description': 'Retrieves a project by its ID. Raises a custom HTTP exception if the project is not found.'}, {'method': 'PUT', 'path': '/projects/{project_id}', 'response_model': 'ProjectUpdate', 'description': 'Updates an existing project. The updated project data should be provided in the request body.'}], 'dependencies': ['fastapi.APIRouter', 'fastapi.Depends', 'fastapi.HTTPException', 'sqlalchemy.orm.Session', 'app.core.config.get_settings', 'app.core.security.verify_token', 'app.db.session.get_db', 'app.models.project.Project', 'app.schemas.project_schema.ProjectCreate', 'app.schemas.project_schema.ProjectUpdate', 'app.services.project_service.project_service']}\nCONTENT:\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom app.core.config import get_settings\nfrom app.core.security import verify_token\nfrom app.db.session import get_db\nfrom app.models.project import Project\nfrom app.schemas.project_schema import ProjectCreate, ProjectUpdate\nfrom app.services.project_service import project_service\n\nrouter = APIRouter()\n\nclass CustomHTTPException(HTTPException):\n    def __init__(self, status_code: int, detail: str):  # type: ignore\n        super().__init__(status_code=status_code, detail=detail)\n\n@router.post('/projects', response_model=ProjectCreate)\nasync def create_project(\n    project_data: ProjectCreate,\n    db: Session = Depends(get_db),\n    token: str = Depends(verify_token)\n):\n    return project_service.create_project(project_data, db)\n\n@router.get('/projects/{project_id}', response_model=Project)\nasync def get_project(\n    project_id: int,\n    db: Session = Depends(get_db),\n    token: str = Depends(verify_token)\n):\n    project = await project_service.get_project(project_id, db)\n    if not project:\n        raise CustomHTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Project not found')\n    return project\n\n@router.put('/projects/{project_id}', response_model=ProjectUpdate)\nasync def update_project(\n    project_id: int,\n    project_data: ProjectUpdate,\n    db: Session = Depends(get_db),\n    token: str = Depends(verify_token)\n):\n    updated_project = await project_service.update_pr",
      "metadata": {
        "type": "code",
        "len": 2113
      },
      "added": 1756648910.9342732
    },
    {
      "doc_id": "app/routers/task_router.py",
      "text": "FILE: app/routers/task_router.py\nSUMMARY: This file defines routes for managing tasks in a FastAPI application using SQLAlchemy for database operations and custom services for task-related logic. It includes endpoints to create, retrieve, update, and delete tasks, with authorization checks based on the current user.\nCONTENT:\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom app.core.security import get_current_user\nfrom app.db.session import get_db\nfrom app.models.task import Task\nfrom app.schemas.task import TaskCreate, TaskUpdate, TaskResponse\nfrom app.services.project_service import project_service\nfrom app.services.task_service import task_service\n\nrouter = APIRouter(prefix=\"/tasks\", tags=[\"Tasks\"])\n\n@router.post(\"/\")\ndef create_task(task: TaskCreate, db: Session = Depends(get_db), current_user: dict = Depends(get_current_user)):\n    project_id = task.project_id\n    if not project_service.get_project_by_id(db, project_id):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Project not found\")\n    return task_service.create_task(db, task, current_user)\n\n@router.get(\"/\")\ndef get_tasks(db: Session = Depends(get_db), current_user: dict = Depends(get_current_user)):\n    return task_service.get_tasks_by_user_id(db, current_user[\"id\"])\n\n@router.get(\"/{task_id}\")\ndef get_task(task_id: int, db: Session = Depends(get_db), current_user: dict = Depends(get_current_user)):\n    task = task_service.get_task_by_id(db, task_id)\n    if not task or task.owner_id != current_user[\"id\"]:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Task not found\")\n    return task\n\n@router.put(\"/{task_id}\")\ndef update_task(task_id: int, task: TaskUpdate, db: Session = Depends(get_db), current_user: dict = Depends(get_current_u",
      "metadata": {
        "type": "code",
        "len": 2169
      },
      "added": 1756648912.1182382
    },
    {
      "doc_id": "app/migrations/versions/",
      "text": "FILE: app/migrations/versions/\nSUMMARY: This directory is used to store database migration scripts generated by Alembic for the 'app' project.\nCONTENT:\n# Directory for storing database migration scripts using Alembic.\n# Generated for: app/migrations/versions/\nprint('LLM-generated placeholder for app/migrations/versions/')\n",
      "metadata": {
        "type": "code",
        "len": 172
      },
      "added": 1756648913.9633393
    },
    {
      "doc_id": "success_1756648917_87",
      "text": "SUCCESSFUL PROJECT PATTERN\nScore: 87/100\nPrompt: Build a collaborative project management system with team workspaces, project hierarchies, task dependencies, time tracking, milestone management, reporting dashboards, and custom workflows. Use PostgreSQL with full-text search.\nTech Stack: fastapi+python, react+ts\nFiles Generated: 12\nArchitecture Pattern: Clean Architecture\n\nKEY LEARNINGS:\n- This prompt pattern works well with tech stack: ['fastapi+python', 'react+ts']\n- Generated 12 files with score 87\n- Architecture: Clean Architecture\n- Success factors: comprehensive file coverage, working code generation\n\nPROMPT CLASSIFICATION:\nadmin_interface\n\nTECH STACK EFFECTIVENESS:\nExcellent match: ['fastapi+python', 'react+ts'] produced high-quality results\n\nFILES CREATED:\napp/core/config.py\napp/core/security.py\napp/db/base_model.py\napp/db/session.py\napp/models/project.py\napp/models/task.py\napp/services/project_service.py\napp/routers/project_router.py\napp/routers/task_router.py\napp/main.py",
      "metadata": {
        "type": "knowledge",
        "score": 87,
        "tech_stack": [
          "fastapi+python",
          "react+ts"
        ],
        "file_count": 12,
        "prompt_category": "admin_interface",
        "added": 1756648917.1019626
      },
      "added": 1756648917.1019626
    }
  ]
}